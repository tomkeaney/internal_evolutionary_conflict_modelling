[
  {
    "objectID": "deterministic_sim.html",
    "href": "deterministic_sim.html",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for purrr, ggplot, dplyr and more \nlibrary(patchwork) # for combining plots\nlibrary(rcartocolor) # for cool colours\nlibrary(kableExtra) # scrolling tables\nlibrary(pander) # other nice tables\nlibrary(stickylabeller) # for labelling ggplot facets\nlibrary(geomtextpath)\nlibrary(ggnewscale) # for multiple scales in a single plot"
  },
  {
    "objectID": "deterministic_sim.html#load-packages",
    "href": "deterministic_sim.html#load-packages",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for purrr, ggplot, dplyr and more \nlibrary(patchwork) # for combining plots\nlibrary(rcartocolor) # for cool colours\nlibrary(kableExtra) # scrolling tables\nlibrary(pander) # other nice tables\nlibrary(stickylabeller) # for labelling ggplot facets\nlibrary(geomtextpath)\nlibrary(ggnewscale) # for multiple scales in a single plot"
  },
  {
    "objectID": "deterministic_sim.html#introduction-to-the-problem",
    "href": "deterministic_sim.html#introduction-to-the-problem",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Introduction to the problem",
    "text": "Introduction to the problem\nHere, we use recursions to investigate the invasion of an autosomal segregation distorting (SD) allele (hereafter SD). We denote the resident allele, which does not cause segregation distortion, W. We explore models where segregation distortion occurs during 1) gametogenesis and 2) is limited to sperm development, such that a proportion \\(k\\) of the gametes produced by a heterozygote carry the SD allele. In both cases, the distorting effect is limited to heterozygous individuals. As commonly observed in natural systems, we assume that homozygous SDSD genotypes are inviable, but that there are no viability costs associated with heterozygotes."
  },
  {
    "objectID": "deterministic_sim.html#build-the-mating-table",
    "href": "deterministic_sim.html#build-the-mating-table",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Build the mating table",
    "text": "Build the mating table\nOne of the more common elements of pop-gen models is the mating table. They illustrate the ‘rules of the game’.\nHere, we use the “mating table” to list of all the possible mating types (e.g. a WSD mother with a WSD father, etc), the resulting possible offspring genotypes, and their associated frequencies. The precise values in the mating table are a function of k (i.e. the strength of segregation distortion). We assume that meiosis is Mendelian except in WSD individuals (or just males), and that all crosses produce a 50:50 sex ratio.\n\n\n\n\n\n\nNote\n\n\n\nExplore the code chunk below to see how we calculated zygote frequencies for every possible mating combination.\n\n\n\n\nCode\nmake_mating_table &lt;- function(k){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n  \n  # Set up the 18 possible mating types - this just helps to build the combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"WW_female\",\n               \"WSD\",\n               \"SDSD\"),\n    father = c(\"WW\",\n               \"WSD\",\n               \"SDSD\"),\n    sex_limited_drive = c(\"YES\", \"NO\"))\n  \n  # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # WW x WW\n  \n  g0 &lt;- c(\"WW_female\", \"WW_male\")\n  \n  # WSD x WW & WW x WSD\n  \n  g1 &lt;- c(\"WW_female\", \"WW_male\", \"WSD_female\", \"WSD_male\")\n  \n  # SDSD x WW & WW x SDSD\n  \n  g2 &lt;- c(\"WSD_female\", \"WSD_male\")\n  \n  # WSD x WSD\n  \n  g3 &lt;- c(\"WW_female\", \"WW_male\", \"WSD_female\", \"WSD_male\", \"SDSD_female\", \"SDSD_male\")\n  \n  # WSD x SDSD & SDSD x WSD\n  \n  g4 &lt;- c(\"WSD_female\", \"WSD_male\", \"SDSD_female\", \"SDSD_male\")\n  \n  # SDSD x SDSD\n  \n  g5 &lt;- c(\"SDSD_female\", \"SDSD_male\")\n  \n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # now offspring frequencies when there's drive\n  \n  # when there are 4 offspring genotypes\n  \n  p1 &lt;- c(0.5 * (1 - k), \n          0.5 * (1 - k), \n          0.5 * k, \n          0.5 * k)\n  \n  # when there are 6 offspring genotypes\n  \n  p2 &lt;- c(0.25 * (1 - k),\n          0.25 * (1 - k),\n          (0.25 * (1 - k)) + (0.25 * k),\n          (0.25 * (1 - k)) + (0.25 * k),\n          0.25 * k,\n          0.25 * k)\n  \n  # Now what happens when there is drive in both sexes\n  \n  # when there are 6 offspring genotypes\n  \n  p3 &lt;- c(0.5 * ((1 - k)^2),\n          0.5 * ((1 - k)^2),\n          k*(1-k),\n          k*(1-k),\n          0.5*(k^2),\n          0.5*(k^2))\n  \n  left_join(\n    bind_rows(\n      list(\n        make_offspring(\"WW\", \"WW\", g0, rep5),\n        make_offspring(\"WW\", \"WSD\", g1, p1),\n        make_offspring(\"WW\", \"SDSD\", g2, rep5),\n        make_offspring(\"WSD\", \"WW\", g1, rep25),\n        make_offspring(\"WSD\", \"WSD\", g3, p2),\n        make_offspring(\"WSD\", \"SDSD\", g4, rep25),\n        make_offspring(\"SDSD\", \"WW\", g2, rep5),\n        make_offspring(\"SDSD\", \"WSD\", g4, p1),\n        make_offspring(\"SDSD\", \"SDSD\", g5, rep5)\n      )) %&gt;% \n      arrange(mother, father) %&gt;%\n      rename(zygote_freq_male_limited_drive = zygote_freq),\n    \n    \n    bind_rows(\n      list(  \n        make_offspring(\"WW\", \"WW\", g0, rep5),\n        make_offspring(\"WW\", \"WSD\", g1, p1),\n        make_offspring(\"WW\", \"SDSD\", g2, rep5),\n        make_offspring(\"WSD\", \"WW\", g1, p1),\n        make_offspring(\"WSD\", \"WSD\", g3, p3),\n        make_offspring(\"WSD\", \"SDSD\", g4, p1),\n        make_offspring(\"SDSD\", \"WW\", g2, rep5),\n        make_offspring(\"SDSD\", \"WSD\", g4, p1),\n        make_offspring(\"SDSD\", \"SDSD\", g5, rep5)\n      )) %&gt;% \n      arrange(mother, father) %&gt;%\n      rename(zygote_freq_heterozygote_drive = zygote_freq)\n  )\n  \n}"
  },
  {
    "objectID": "deterministic_sim.html#an-example-of-a-mating-table",
    "href": "deterministic_sim.html#an-example-of-a-mating-table",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "An example of a mating table",
    "text": "An example of a mating table\nWhen \\(k\\) = 0.9 we get\n\n\nCode\n# Make the table\n\nmake_mating_table(k = 0.9) %&gt;% \n  rename(`zygote type` = type,\n         `zygote freq: male-limited drive` = zygote_freq_male_limited_drive,\n         `zygote freq: drive in both sexes` = zygote_freq_heterozygote_drive) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\n\n\n\n\nmother\nfather\nzygote type\nzygote freq: male-limited drive\nzygote freq: drive in both sexes\n\n\n\n\nSDSD\nSDSD\nSDSD_female\n0.500\n0.500\n\n\nSDSD\nSDSD\nSDSD_male\n0.500\n0.500\n\n\nSDSD\nWSD\nWSD_female\n0.050\n0.050\n\n\nSDSD\nWSD\nWSD_male\n0.050\n0.050\n\n\nSDSD\nWSD\nSDSD_female\n0.450\n0.450\n\n\nSDSD\nWSD\nSDSD_male\n0.450\n0.450\n\n\nSDSD\nWW\nWSD_female\n0.500\n0.500\n\n\nSDSD\nWW\nWSD_male\n0.500\n0.500\n\n\nWSD\nSDSD\nWSD_female\n0.250\n0.050\n\n\nWSD\nSDSD\nWSD_male\n0.250\n0.050\n\n\nWSD\nSDSD\nSDSD_female\n0.250\n0.450\n\n\nWSD\nSDSD\nSDSD_male\n0.250\n0.450\n\n\nWSD\nWSD\nWW_female\n0.025\n0.005\n\n\nWSD\nWSD\nWW_male\n0.025\n0.005\n\n\nWSD\nWSD\nWSD_female\n0.250\n0.090\n\n\nWSD\nWSD\nWSD_male\n0.250\n0.090\n\n\nWSD\nWSD\nSDSD_female\n0.225\n0.405\n\n\nWSD\nWSD\nSDSD_male\n0.225\n0.405\n\n\nWSD\nWW\nWW_female\n0.250\n0.050\n\n\nWSD\nWW\nWW_male\n0.250\n0.050\n\n\nWSD\nWW\nWSD_female\n0.250\n0.450\n\n\nWSD\nWW\nWSD_male\n0.250\n0.450\n\n\nWW\nSDSD\nWSD_female\n0.500\n0.500\n\n\nWW\nSDSD\nWSD_male\n0.500\n0.500\n\n\nWW\nWSD\nWW_female\n0.050\n0.050\n\n\nWW\nWSD\nWW_male\n0.050\n0.050\n\n\nWW\nWSD\nWSD_female\n0.450\n0.450\n\n\nWW\nWSD\nWSD_male\n0.450\n0.450\n\n\nWW\nWW\nWW_female\n0.500\n0.500\n\n\nWW\nWW\nWW_male\n0.500\n0.500"
  },
  {
    "objectID": "deterministic_sim.html#determine-the-mating-type-frequencies-of-the-population",
    "href": "deterministic_sim.html#determine-the-mating-type-frequencies-of-the-population",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Determine the mating type frequencies of the population",
    "text": "Determine the mating type frequencies of the population\nHere we build a helper function to calculate the expected frequencies of each possible mating combination (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females, the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male adult genotype frequencies. Note that all the fitness effects (distortion and genotype viability) are accounted for here.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father genotypes\n    mutate(prop_matings = 0) # make placeholder column we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(mating_types)){\n    mating_types$prop_matings[i] &lt;- \n      female_frequencies$prop[female_frequencies$type == mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == mating_types$father[i]]\n  }\n  \n  mating_types %&gt;% # output\n    rename(mating_type_freq = prop_matings) %&gt;% \n    select(mother, father, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father = str_remove_all(father, \"_male\"))\n}"
  },
  {
    "objectID": "deterministic_sim.html#create-a-simple-function-to-find-the-population-wide-frequency-of-sd",
    "href": "deterministic_sim.html#create-a-simple-function-to-find-the-population-wide-frequency-of-sd",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Create a simple function to find the population-wide frequency of SD",
    "text": "Create a simple function to find the population-wide frequency of SD\n\n\nCode\ncalc_prop_SD &lt;- function(pop){\n  0.5 * sum(pop$prop[str_detect(pop$type, \"WSD\")]) + sum(pop$prop[str_detect(pop$type, \"SDSD\")])\n}"
  },
  {
    "objectID": "deterministic_sim.html#build-the-main-simulation-function",
    "href": "deterministic_sim.html#build-the-main-simulation-function",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Build the main simulation function",
    "text": "Build the main simulation function\nThis is how we actually run the recursions. This large function uses our two helper functions, find_mating_type_frequencies and calc_prop_SD that we build above.\n\n\n\n\n\n\nNote\n\n\n\nI wrote this code to be readable, not fast. The task is computationally quite manageable, making this an inexpensive trade-off. Functions like left_join should be avoided if you require faster code.\n\n\n\n\nCode\nrun_recursions &lt;- function(row, parameters, sex_limited){\n  \n  print(paste(\"Doing row\", row)) # this tells you which row in the parameter space is being modelled\n  \n  # Get the focal parameter space out of parameters[row], this makes it easier later\n  \n  generations &lt;- parameters$generations[row]\n  k &lt;- parameters$k[row]\n  egg_adult_viability_WSD_female &lt;- parameters$egg_adult_viability_WSD_female[row]\n  egg_adult_viability_SDSD_female &lt;- parameters$egg_adult_viability_SDSD_female[row]\n  egg_adult_viability_WSD_male &lt;- parameters$egg_adult_viability_WSD_male[row]\n  egg_adult_viability_SDSD_male &lt;- parameters$egg_adult_viability_SDSD_male[row]\n  initial_freq_SD &lt;- parameters$initial_freq_SD[row]\n  \n  # Make the initial population\n  pop &lt;-\n    tibble(\n      type = c(\"WW_female\",\n               \"WSD_female\",\n               \"SDSD_female\",\n               \"WW_male\",\n               \"WSD_male\",\n               \"SDSD_male\"),\n      prop = c(0.5 * (1 - initial_freq_SD) ^ 2,\n               0.5 * (1 - initial_freq_SD) * initial_freq_SD * 2,\n               0.5 * (initial_freq_SD^2),\n               0.5 * (1 - initial_freq_SD) ^ 2,\n               0.5 * (1 - initial_freq_SD) * initial_freq_SD * 2,\n               0.5 * (initial_freq_SD^2)),\n      egg_adult_viability = c(1, egg_adult_viability_WSD_female, \n                              egg_adult_viability_SDSD_female, 1,\n                              egg_adult_viability_WSD_male, egg_adult_viability_SDSD_male)) %&gt;%\n    arrange(type)\n  \n  # Make the mating table for this specific parameter space\n  \n  mating_table &lt;- make_mating_table(k) # we only have to load the pre-created table once\n  \n  # Input the fitnesses of each genotype\n  \n  fitnesses &lt;- pop %&gt;%\n    select(type, egg_adult_viability)\n  \n  # Prepare for recursions\n  current_generation &lt;- 1\n  keep_going &lt;- TRUE # a quit condition, if this switches to false the sim will end\n  \n  # create a matrix to track the frequencies of SD every generation\n  # specify two columns because we'd like to know the freq in zygotes and the freq in adults\n  freq_table &lt;- matrix(nrow = generations + 1, ncol = 2) \n  # provide the first entry, starting with zygotes\n  freq_table[1, ] &lt;- initial_freq_SD\n  \n  # Iterate over generations\n  \n  while(current_generation &lt;= generations & keep_going){\n    \n    # Use our pre-made function to enact viability selection, find the mating type frequencies and renormalise the frequencies to sum to one every generation\n    \n    mating_type_frequencies &lt;- find_mating_type_frequencies(pop = pop)\n    \n    # Now make the new pop table, using the new mating type frequencies\n    \n    if(sex_limited == TRUE){ # drive is just through males\n      pop &lt;- \n        left_join(mating_table, mating_type_frequencies, by = c(\"mother\", \"father\")) %&gt;%\n        # find the offspring frequencies, this is where the distortion effect is coded\n        mutate(prop = mating_type_freq * zygote_freq_male_limited_drive) %&gt;%\n        group_by(type) %&gt;%\n        summarise(prop = sum(prop)) %&gt;%\n        left_join(fitnesses, by = \"type\")\n    } else{ # drive occurs in both sexes\n      pop &lt;- \n        left_join(mating_table, mating_type_frequencies, by = c(\"mother\", \"father\")) %&gt;%\n        # find the offspring frequencies, this is where the distortion effect is coded\n        mutate(prop = mating_type_freq * zygote_freq_heterozygote_drive) %&gt;%\n        group_by(type) %&gt;%\n        summarise(prop = sum(prop)) %&gt;%\n        left_join(fitnesses, by = \"type\")\n    }\n    \n    # update the results matrix\n    # our pop matrix tracks the frequencies of zygotes, fill column one with these freqs\n    freq_table[current_generation + 1, 1] &lt;-\n      pop %&gt;% mutate(prop = prop/sum(prop)) %&gt;%\n      calc_prop_SD()\n    \n    # fill column two with allele frequencies among adults\n    freq_table[current_generation + 1, 2] &lt;-\n      pop %&gt;% mutate(prop = prop*egg_adult_viability) %&gt;% mutate(prop = prop/sum(prop)) %&gt;%\n      calc_prop_SD()\n    \n    # Calculate the frequency of SD\n    prop_SD &lt;- calc_prop_SD(pop)\n    # Quit early if SD fixes or goes extinct-ish\n    if(prop_SD &gt; 0.99 | prop_SD &lt; 0.005) keep_going &lt;- FALSE\n    \n    # Increment the generation counter by 1 and return to top of the 'while' loop\n    current_generation &lt;- current_generation + 1\n  }\n  \n  freq_table # returns the final pop\n  \n}"
  },
  {
    "objectID": "deterministic_sim.html#run-the-simulation",
    "href": "deterministic_sim.html#run-the-simulation",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Run the simulation",
    "text": "Run the simulation\n\n\nCode\nif(!file.exists(\"simulation_results/sex_lim_results.rds\")){\nsex_lim_results &lt;- \n  lapply(1:nrow(parameters), run_recursions, parameters = parameters, sex_limited = TRUE)\n\nsaveRDS(sex_lim_results, \"simulation_results/sex_lim_results.rds\")\n\nboth_sexes_results &lt;- \n  lapply(1:nrow(parameters), run_recursions, parameters = parameters, sex_limited = FALSE)\n\nsaveRDS(both_sexes_results, \"simulation_results/both_sexes_results.rds\")\n}else{\n  sex_lim_results &lt;- read_rds(\"simulation_results/sex_lim_results.rds\")\n  both_sexes_results &lt;- read_rds(\"simulation_results/both_sexes_results.rds\")\n}"
  },
  {
    "objectID": "deterministic_sim.html#wrangle-the-results-for-plotting",
    "href": "deterministic_sim.html#wrangle-the-results-for-plotting",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Wrangle the results for plotting",
    "text": "Wrangle the results for plotting\nGet the results from a single run\n\n\nCode\nsingle_run_sex_lim &lt;- \n  sex_lim_results[[81]] %&gt;% \n  as_tibble() %&gt;% \n  rename(Zygotes = V1,\n         Adults = V2) %&gt;% \n  mutate(gen = 1:n(),\n         drive = \"Male-limited drive\")\n\nsingle_run_all_het &lt;- \n  both_sexes_results[[81]] %&gt;% \n  as_tibble() %&gt;% \n  rename(Zygotes = V1,\n         Adults = V2) %&gt;% \n  mutate(gen = 1:n(),\n         drive = \"Drive in all heterozygotes\")\n\nsingle_run &lt;-\n  rbind(single_run_sex_lim,\n        single_run_all_het) %&gt;% \n  pivot_longer(cols = 1:2, names_to = \"Census point\", values_to = \"Frequency\")\n\n\nGet the endpoints of all simulations\n\n\nCode\nresults_wrangler &lt;- \n  function(input, row){\n    as.data.frame(input[row]) %&gt;% \n      filter(!is.na(X1)) %&gt;% \n      slice_tail(n = 1) %&gt;% \n      mutate(parameter_space_ID = row,\n             X1 = round(X1, 3),\n             X2 = round(X2, 3))\n  }\n\nsex_lim_tidy_results &lt;- \n  map_dfr(1:nrow(parameters),\n          results_wrangler,\n          input = sex_lim_results) %&gt;% \n  rename(Zygotes = X1,\n         Adults = X2) %&gt;%\n  mutate(drive = \"Male-limited drive\") %&gt;% \n  left_join(parameters, by = \"parameter_space_ID\")\n\nboth_sexes_tidy_results &lt;- \n  map_dfr(1:nrow(parameters),\n          results_wrangler,\n          input = both_sexes_results) %&gt;% \n  rename(Zygotes = X1,\n         Adults = X2) %&gt;% \n  mutate(drive = \"Drive in all heterozygotes\") %&gt;% \n  left_join(parameters, by = \"parameter_space_ID\")\n\ncomplete_results &lt;-\n  bind_rows(sex_lim_tidy_results,\n            both_sexes_tidy_results) %&gt;% \n  as_tibble() %&gt;% \n  pivot_longer(cols = Zygotes:Adults, \n               names_to = \"Census point\",\n                values_to = \"Prop. driver\")"
  },
  {
    "objectID": "deterministic_sim.html#plot-the-results",
    "href": "deterministic_sim.html#plot-the-results",
    "title": "Deterministic simulation of male-limited segregation distorter",
    "section": "Plot the results",
    "text": "Plot the results\nFirst, let’s plot the evolutionary trajectory of the SD allele when \\(k=0.9\\).\n\n\nCode\nsingle_run %&gt;% \n  ggplot(aes(x = gen, y = Frequency, group = `Census point`)) +\n  geom_textline(aes(label = `Census point`), hjust = 0.75) +\n  labs(x = \"Generations\",\n       y = \"Equilibrium freq. of driving allele\") +\n  facet_wrap(~drive) +\n  scale_x_continuous(expand = c(0, 0.01), limits = c(0,100)) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 16),\n        strip.background = element_rect(colour = \"black\",\n                                        fill = \"Aliceblue\",\n                                        size = .8),\n        panel.spacing.x = unit(10, \"mm\"))\n\n\n\n\n\n\n\n\n\nNow let’s plot the equilibrium frequency for all values of \\(k\\)\n\n\nCode\ncomplete_results %&gt;% \n  ggplot(aes(x = k, y = `Prop. driver`, group = `Census point`)) +\n  geom_textline(aes(label = `Census point`)) +\n  #geom_line(data = Bruck_results, colour = \"orange\") +\n  labs(x = \"Strength of drive (k)\",\n       y = \"Equilibrium freq. of driving allele\") +\n  facet_wrap(~drive) +\n  scale_x_continuous(expand = c(0, 0.01)) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +\n  theme_bw() +\n  theme(text = element_text(size = 16),\n        strip.background = element_rect(colour = \"black\",\n                                        fill = \"Aliceblue\",\n                                        size = .8),\n        panel.spacing.x = unit(10, \"mm\"))"
  }
]